# 抽象相等比较算法
在面试或工作中我们经常碰到这样的问题
1. []==[]
2. []==![] 
3. {}==!{} 
4. ![]=={} 
5. []==!{} 
6. undefined==null
7. [0]==false
8. [“”]==true
9. [0,1]==false

[官方文档](http://es5.github.io/#x11.9.3)

**预备知识**
+ JS中的值有两种类型：原始类型(Primitive)、对象类型(Object)
+ 原始类型包括：Undefined、Null、Boolean、Number和String五种
+ Undefined类型和Null类型的都只有一个值，即undefined和null；Boolean类型有两个值：true和false；Number类型的值有很多很多；String类型的值理论上有无数个
+ 所有对象都有valueOf()和toString()方法
   + {a:1}.valueOf()      //   {a:1}
   + [1,2].valueOf()       //  [1,2]
   + {a:1}.toString()     //  "[object Object] "
   + [1,2].toString()      //   "1,2"
+ Number()
   + Number([1])       //    1
   + Number([1,2])     //   NaN
   + Number([" "])     //   0
   + Number(" ")      //   0   

#### 官方文档的中文译文如下：
---
*比较x == y，其中x和y是值，产生true或false。这样的比较如下进行：*

1. *如果 Type（x）与Type（y）相同，那么*
   1. *如果 Type（x）是Undefined，则返回true。*
   2. *如果 Type（x）为Null，则返回true。* 
   3. *如果 Type（x）是Number，那么*
      + *如果 x是NaN，则返回false。*
      + *如果 y是NaN，则返回false。*
      + *如果 x与y的 Number值相同，则返回true。*
      + *如果 x为+0且y为-0，则返回true。*
      + *如果 x为-0且y为+0，则返回true。*
      + *返回 false。*
   4. *如果 Type（x）是String，则当x和y是完全相同的字符序列（相应位置有相同长度和相同字符），则返回true。否则，返回false。*
   5. *如果 Type（x）是Boolean，如果x和y都为true或两者都为false，则返回true。否则，返回 false。*
   6. *如果x和y引用同一个对象，则返回 true。否则，返回false。*
2. *如果x是null且y是undefined，返回 true。*
3. *如果x是undefined且y为null，返回 true。*
4. *如果 Type（x）为Number且Type（y）为String，则返回比较 x == ToNumber（y）的结果。*
5. *如果 Type（x）是String并且Type（y）是Number，则返回比较ToNumber（x）== y的结果。*
6. *如果 Type（x）是Boolean，则返回比较 ToNumber（x）== y的结果。*
7. *如果 Type（y）是Boolean，则返回比较x == ToNumber（y）的结果。*
8. *如果 Type（x）是String或Number而Type（y）是Object，则返回比较x == ToPrimitive（y）的结果。*
9. *如果 Type（x）是Object而Type（y）是String或Number，则返回比较ToPrimitive（x）== y的结果。*
10. *返回 false。*
---
上述中提到的ToPrimitive(obj)等价于：先计算obj.valueOf()，如果结果为原始值，则返回此结果；否则，计算obj.toString()，如果结果是原始值，则返回此结果；否则，抛出异常。    
ToNumber()，即将操作数转为数字。可以用刚才提到的Number()函数来等价替代。
